import ResponseHistory from '../models/ResponseHistory.js';
import UserProfile from '../models/UserProfile.js';

/**
 * Exploit Detection Service
 * 
 * SPEC #3: Exploit Surface Lockdown
 * - Detect pattern replay across scenarios
 * - Detect role switching abuse
 * - Detect cooperative farming
 * - Apply cooldown/freeze on exploit detection
 */

// ==========================================
// PATTERN REPLAY DETECTION
// ==========================================

/**
 * Detect if user is replaying similar responses
 * Returns similarity analysis with exploit flag
 */
export const detectPatternReplay = async (userId, currentResponse, sessionId, problemId) => {
    // Check similarity with previous responses
    const analysis = await ResponseHistory.checkSimilarity(userId, currentResponse);

    // Store this response for future comparison
    await ResponseHistory.create({
        user_id: userId,
        session_id: sessionId,
        problem_id: problemId,
        response_hash: analysis.response_hash,
        keywords: analysis.keywords,
        similarity_scores: analysis.similarities,
        exploit_flag: analysis.exploit_detected,
        exploit_reason: analysis.exploit_reason
    });

    return {
        max_similarity: analysis.max_similarity,
        exploit_detected: analysis.exploit_detected,
        exploit_reason: analysis.exploit_reason,
        similar_sessions: analysis.similarities.length
    };
};

// ==========================================
// ROLE SWITCHING ABUSE DETECTION
// ==========================================

/**
 * Detect if user is rapidly switching archetypes to farm XP
 * Abuse pattern: switching archetype frequently to get "new player" bonuses
 */
export const detectRoleSwitchingAbuse = async (userId, timeWindowMs = 3600000) => {
    // Get recent response history
    const recentResponses = await ResponseHistory.find({
        user_id: userId,
        created_at: { $gte: new Date(Date.now() - timeWindowMs) }
    }).sort({ created_at: -1 }).lean();

    if (recentResponses.length < 3) {
        return { abuse_detected: false };
    }

    // Count unique archetypes in the time window
    const archetypes = recentResponses.map(r => r.archetype_used).filter(Boolean);
    const uniqueArchetypes = new Set(archetypes);

    // Calculate switch frequency
    let switchCount = 0;
    for (let i = 1; i < archetypes.length; i++) {
        if (archetypes[i] !== archetypes[i - 1]) {
            switchCount++;
        }
    }

    // Abuse detected if:
    // - More than 3 switches in the time window
    // - OR using all 4 archetypes within a short period
    const abuseDetected = switchCount > 3 || (uniqueArchetypes.size === 4 && recentResponses.length < 10);

    return {
        abuse_detected: abuseDetected,
        switch_count: switchCount,
        unique_archetypes: uniqueArchetypes.size,
        sessions_analyzed: recentResponses.length,
        reason: abuseDetected ?
            `Rapid archetype switching detected: ${switchCount} switches in ${recentResponses.length} sessions` :
            null
    };
};

// ==========================================
// COOPERATIVE FARMING DETECTION
// ==========================================

/**
 * Detect cooperative farming patterns
 * This is where multiple accounts work together to boost each other
 * For now, we detect based on similar response patterns across users
 */
export const detectCooperativeFarming = async (userId, currentResponse) => {
    const responseHash = ResponseHistory.createResponseHash(currentResponse);

    // Find other users with same response hash (exact match)
    const sameResponses = await ResponseHistory.find({
        response_hash: responseHash,
        user_id: { $ne: userId }
    }).limit(5).lean();

    if (sameResponses.length > 0) {
        // Multiple users with exact same response = suspicious
        return {
            farming_detected: true,
            related_users: sameResponses.map(r => r.user_id),
            reason: `Response matches ${sameResponses.length} other user(s) - possible cooperative farming`
        };
    }

    return { farming_detected: false };
};

// ==========================================
// COOLDOWN MANAGEMENT
// ==========================================

/**
 * Determine if cooldown should be applied based on detection results
 */
export const shouldApplyCooldown = (detectionResults) => {
    const { patternReplay, roleSwitching, cooperativeFarming } = detectionResults;

    // Exact pattern replay = 1 hour cooldown
    if (patternReplay?.max_similarity >= 1.0) {
        return {
            apply: true,
            duration_ms: 3600000, // 1 hour
            reason: 'Exact pattern replay detected'
        };
    }

    // High similarity = 30 minute cooldown
    if (patternReplay?.max_similarity >= 0.85) {
        return {
            apply: true,
            duration_ms: 1800000, // 30 minutes
            reason: patternReplay.exploit_reason
        };
    }

    // Role switching abuse = 2 hour cooldown
    if (roleSwitching?.abuse_detected) {
        return {
            apply: true,
            duration_ms: 7200000, // 2 hours
            reason: roleSwitching.reason
        };
    }

    // Cooperative farming = 4 hour cooldown
    if (cooperativeFarming?.farming_detected) {
        return {
            apply: true,
            duration_ms: 14400000, // 4 hours
            reason: cooperativeFarming.reason
        };
    }

    return { apply: false };
};

/**
 * Apply cooldown to user
 */
export const applyCooldown = async (userId, durationMs, reason) => {
    const profile = await UserProfile.findOne({ user_id: userId });
    if (!profile) return null;

    profile.exploit_cooldown_until = new Date(Date.now() + durationMs);
    await profile.save();

    return {
        cooldown_applied: true,
        until: profile.exploit_cooldown_until,
        duration_seconds: durationMs / 1000,
        reason
    };
};

/**
 * Check if user is in cooldown
 */
export const isInCooldown = async (userId) => {
    const profile = await UserProfile.findOne({ user_id: userId });
    if (!profile) return { in_cooldown: false };

    if (profile.exploit_cooldown_until && profile.exploit_cooldown_until > new Date()) {
        return {
            in_cooldown: true,
            until: profile.exploit_cooldown_until,
            remaining_seconds: Math.ceil((profile.exploit_cooldown_until - new Date()) / 1000)
        };
    }

    return { in_cooldown: false };
};

// ==========================================
// FULL EXPLOIT CHECK
// ==========================================

/**
 * Run all exploit detection checks
 */
export const runFullExploitCheck = async (userId, currentResponse, sessionId, problemId) => {
    const results = {
        patternReplay: await detectPatternReplay(userId, currentResponse, sessionId, problemId),
        roleSwitching: await detectRoleSwitchingAbuse(userId),
        cooperativeFarming: await detectCooperativeFarming(userId, currentResponse)
    };

    const cooldownDecision = shouldApplyCooldown(results);

    if (cooldownDecision.apply) {
        await applyCooldown(userId, cooldownDecision.duration_ms, cooldownDecision.reason);
    }

    return {
        ...results,
        cooldown: cooldownDecision,
        any_exploit_detected: cooldownDecision.apply
    };
};

export default {
    detectPatternReplay,
    detectRoleSwitchingAbuse,
    detectCooperativeFarming,
    shouldApplyCooldown,
    applyCooldown,
    isInCooldown,
    runFullExploitCheck
};
